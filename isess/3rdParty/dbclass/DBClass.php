<?php

/**
 * @author IPCS Nig. Limited
 * @copyright 2010
 * 
 */

require_once("ConnException.php");
require_once("QueryException.php");
require_once("constants.php");

/**
 * 
 * @name    DBClass
 * */
class DBClass
{
    
    /**
     * The DB server host
     * @access  protected
     * */
    protected $host; 
    
    /**
     * The name of the database
     * @access  protected
     * */
    protected $dbname;
    
    /**
     * The DB prefix (if any) for shared hosting
     * @access  protected
     * */
    protected $prefix;
    
    /**
     * The username to be used for connecting to the DB
     * @access  protected
     * */
    protected $user;
    
    /**
     * The password for the user account
     * @access  protected
     * */
    protected $passwd;
    
    /**
     * This will keep the name of the DB server to be connected to
     * @todo    Change this to an enum or array that will list its values
     * @access  protected 
     * */
    protected $dbserver;
    
    /**
     * This will store the last error generated by a SQL operation
     * @access  protected
     * */
    protected $lastError;
    
    /**
     * This will store the last query executed before an error occured
     * It will be useful for debugging purposes
     * @access  protected
     * */
    protected $lastQuery;
    
    /**
     * This will store the code for the last error generated by an SQL operation
     * @access  protected
     * */
    protected $lastErrorCode;
    
    /**
     * This indicates if the class should operate in debug mode to trace errors
     * @access  public
     * */
    public $debugMode;
    
    /**
     * The state of the connection
     * @access  public
     * */
    public $connState;
    
    /**
     * The instance of the connection that will be used by this class
     * @access  private
     * */
    public $conn;
    
    /**
     * This will refer to an instance of PDOStatement created by the class
     * @access  private
     * */
    private $stmnt;
    
    /**
     * 
     * */
    private static $objInstance;
        
    /**
     * This abstracts the PDO fetch mode of associative
     * */
    const FETCH_MODE_ASSOC = PDO::FETCH_ASSOC;
    
    const FETCH_MODE_NUM = PDO::FETCH_NUM;
    
    const FETCH_MODE_OBJ = PDO::FETCH_OBJ;
    
    const FETCH_MODE_BOTH = PDO::FETCH_BOTH;
    
    const FETCH_MODE_CLASS = PDO::FETCH_CLASS;
    
    const FETCH_MODE_INTO = PDO::FETCH_INTO;
    
    const FETCH_MODE_BIND = PDO::FETCH_BOUND;
    
    const TYPE_INT = PDO::PARAM_INT;
    
    const TYPE_STR = PDO::PARAM_STR;
    
    const TYPE_BOOL = PDO::PARAM_BOOL;
    
    const TYPE_IN_OUT = PDO::PARAM_INPUT_OUTPUT;
    
    
    // Define Methods
    
    /**
     * DBClass::__construct()
     * 
     * @param   void
     * @throws  ConnException
     * @return  void
     */
    private function __construct()
    {
        // Set the class vars
        $this->dbserver = DB_SERVER;
        $this->host = DB_HOST;
        $this->user = DB_USER;
        $this->passwd = DB_PASS;
        $this->prefix = DB_PREFIX;
        
        $this->dbname = (!empty($this->prefix)) ? $this->prefix.'_' : '';
        $this->dbname .= DB_NAME;
        // Set the debug mode
        #$this->debugMode = $debug;
        $this->debugMode = true;
        // create the connection string        
        //$dsn = "mysql:dbname=testdb;host=127.0.0.1";
        // Connect to the DB
        $this->connect();
        
    }
    
    /**
     * DBClass::connect()
     * 
     * @return void
     */
    private function connect()
    {
        $dsn = sprintf('%s:dbname=%s;host=%s', $this->dbserver, $this->dbname, $this->host);
        // now connect to the database 
        try
        {
            $this->conn = new PDO($dsn, $this->user, $this->passwd);
            
            $this->conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            
            //return $dbh;
        }
        catch (PDOException $e)
        {
            // handle the exception
            //return $this->handleConnException($e->getMessage());
            $usermsg = 'Attempted connection to the database failed';
            throw new ConnException($e->getMessage(), $e->getCode(), $usermsg, $dsn);
        }
    } 
    
    /**
     * DBClass::disconnect()
     * 
     * @return void
     */
    protected function disconnect()
    {
        // Set the connection instance to null
        $this->conn = null;
        $this->stmnt = null;
    }   
    
    /**
     * DBClass::__clone()
     * 
     * @return void
     */
    public function __clone()
    {
        trigger_error('Clone is disabled.', E_USER_ERROR);
    }
    
    /**
     * DBClass::__sleep()
     * 
     * This method ensures the an instance of this class can be serialized
     * This method handles disconnecting the PDO object of this calss when serialize is called
     * 
     * @return void
     */
    public function __sleep()
    {
        // Disconnect the active connection
        $this->disconnect();
    }
    
    /**
     * DBClass::__wakeup()
     * 
     * This method ensures the an instance of this class can be serialized
     * This method handles re-initializing the PDO object of this class when unserialize is called on an object of this class
     * 
     * @return void
     */
    public function __wakeup()
    {
        // Create the active connection
        #$this->connect();
        $this->__construct();
    }

    
    /** 
     * DBClass::getInstance()
     * 
     * Returns DB instance or create initial connection 
     * 
     * @param   void
     * @return  DBClass $objInstance - An instance of the class
     * */
    public static function getInstance() 
    { 
            
        if(!self::$objInstance)
        { 
             self::$objInstance = new DBClass();
        } 
        
        return self::$objInstance; 
    
    }
        
    /**
     * This method handles any exception thrown by the operations of the class
     * It displays the error code and error message if the class is in debug mode
     * @todo    Include stack trace if selected in the debug mode
     * */
    protected function handleQueryException($errMsg='')
    {
        // Check the class is in debug mode
        if ($this->debugMode)
        {
            // Ensure that conn is a PDO object
            if (is_a($this->conn, 'PDO'))
            {
                // Attempt to get the error details
                $errDetails = $this->conn->errorInfo();
                // Ensure the error details are not empty
                if (!empty($errDetails))
                {
                    $this->lastErrorCode = $errDetails[1];
                    $this->lastError = $errDetails[2];
                }
                else
                {
                    $this->lastErrorCode = '';
                    $this->lastError = '';
                }
            }
                        
            $errStr = "ERROR!!! \n";
            // Add any error message passed to the function
            
            if (!empty($errMsg))
            {
                // use the passed in error msg
                $errStr .= $errMsg."\n";
            }
            // create the error string
            $errStr .= "Last Error Message : ".$this->lastError."\n";
            $errStr .= "Error Code : ".$this->lastErrorCode."\n";
            $errStr .= "QUERY: ".$this->lastQuery."\n";           
            // Display the error msg and exit
            echo nl2br($errStr);
            exit(); 
            //$this->lastError = $errStr;           
        }
        // This is for none debug mode
        return false;
    }
    
    /**
     * This function handles connection exception
     * It displays an error msg if the class is in debug mode or returns FALSE if not
     * @access  protected
     * @param   string $errMsg - The error message generated when trying to connect
     * */
    protected function handleConnException($errMsg)
    {
        // Check if the class is in debug mode
        if ($this->debugMode)
        {
            $errStr = "ERROR!!! ".$errMsg;
            $errStr .= "\n Host: ".$this->host."\n User: ".$this->user."\n DB: ".$this->dbname;
            // Display the error msg and exit
            echo nl2br($errStr);
            exit();
            //$this->lastError = $errStr;
        }
        // This is for none debug mode
        return false;
    }
    
    /**
     * DBClass::handleException()
     * 
     * @param string $errMsg
     * @return
     */
    protected function handleException($errMsg)
    {
        // Check if the class is in debug mode
        if ($this->debugMode)
        {
            $errStr = "ERROR!!! ".$errMsg;
            // Display the error msg and exit
            echo nl2br($errStr);
            exit();
            //$this->lastError = $errStr;
        }
        // This is for none debug mode
        return false;
    }
    
    /**
     * DBClass::getLastErrorMsg()
     * 
     * This function returns the last error message generated by an operation of this class
     * 
     * @return  string
     */
    public function getLastErrorMsg()
    {
        return $this->lastError;
    }
    
    /**
     * DBClass::getLastErrorCode()
     * 
     * This function returns the last error code generated by an operation of this class
     * 
     * @return  string - The last error code 
     */
    public function getLastErrorCode()
    {
        return $this->lastErrorCode;
    }
    
    /**
     * DBClass::getLastQuery()
     * 
     * This function returns the last query executed by the current instance of the class
     * 
     * @return string DBClass::query - The last query executed by this class
     */
    public function getLastQuery()
    {
        return $this->lastQuery;
    }
    
    /**
     * DBClass::execNonQuery()
     * 
     * This function handles SQL statements that do not return a result set e.g. INSERT, UPDATE or DELETE statements
     * The function returns the number of rows modified by query
     * 
     * @access  public
     * @param   string $sql - The SQL statement to be handled by the function
     * @return  int - The number of rows affected by the query
     * */
    public function execNonQuery($sql)
    {
        // validate if the query is among the allowed queries
        //if (!preg_match("/^(insert|delete|update|replace|drop|create)\\s+/i",$sql) )
        $allowables = array('insert', 'update', 'delete', 'replace', 'drop', 'create');
        if (!preg_match("/^(".implode('|',$allowables).")\\s+/i",$sql))
        {
            //return $this->handleException('This type of query is not cannot be handled by this function');
            $usermsg = 'This type of query cannot be handled by this function';
            throw new QueryException($usermsg, 4000, $sql, $usermsg);
        }            
        else
        {
            try
            {
                // Execute the query
                $affected = $this->conn->exec($sql);
                //$affected = $this->exec($sql);
                // Check if the query returned an error
                if ($affected === false)
                {
                    // call the exception handling function
                    //$this->lastQuery = $sql;
                    // throw the exception
                    throw new QueryException('No record was affected', 4000, $sql, 'No record was affected');                
                }
                else
                {
                    // return the number of rows affected
                    return $affected;
                }
            }
            catch (PDOException $ex)
            {
                //$this->lastQuery = $sql;
                //$this->handleQueryException($ex->getMessage());
                $errInfo = $this->conn->errorInfo();
                throw new QueryException($errInfo[2], $errInfo[1], $sql, 'An error occured while communicating with the DB');
            }                
        }
    }
    
    /**
     * DBClass::execQuery()
     * 
     * This function executes a SELECT query and fetches the result
     * 
     * @access  public
     * @param   string $query - The SQL SELECT query to be executed
     * @param   bool $countOnly - This indicates if only the number of records should be returned without the actual records
     * @param   int $fetchMode - This specifies the mode of the retrieved records
     *                              Its value can be self::FETCH_MODE_ASSOC, self::FETCH_MODE_NUM, self::FETCH_MODE_BOTH, self::FETCH_MODE_OBJ
     * @param   int $numOfRows - The number of records to be retrieved. 0 specifies ALL
     * @return  mixed - The function returns FALSE if an error occurs,
     *                  It returns an INT if only the count was requested
     *                  It returns an ARRAY if the records are required 
     * */
    public function execQuery($query, $countOnly=false, $fetchMode=self::FETCH_MODE_ASSOC, $numOfRows=0)
    {
        $records = array();
        // Execute the query
        $stmnt = '';
        try
        {
            // validate the fetch mode
            $validMode = $this->checkFetchMode($fetchMode);
            // Execute the query 
            $stmnt = $this->conn->query($query);
            
            ###
            ## SQL Error Checking goes here
            ###
            if (!$stmnt)
            {
                $errInfo = $this->conn->errorInfo();
                throw new QueryException($errInfo[2], $errInfo[1], $query, 'The required DB operation failed');
            }
            // Decide if only the count should be returned
            if ($countOnly)
            {
                // Fetch the result and count the records
                $records = $stmnt->fetchAll($validMode);  
                // Close for the cursor for some db servers
                $stmnt->closeCursor();
                // return the count of the records              
                return count($records);
            }
            else
            {
                // decide if only a set of records should be returned
                if ($numOfRows == 0)
                {
                    // fetch all the records
                    $records = $stmnt->fetchAll($validMode);
                }
                else
                {
                    for ($i=0; $i<$numOfRows, $row=$stmnt->fetch($validMode); $i++)
                    {
                        $records[$i] = $row;
                    }
                }  
                // Close for the cursor for some db servers
                $stmnt->closeCursor();              
                // return the records array
                return $records;
            }
        }
        catch (PDOException $ex)
        {
            $this->lastQuery = $query;
            //return $this->handleQueryException($ex->getMessage());
            throw new QueryException($ex->getMessage(), $ex->getCode(), $query, 'The requested operation failed');
        }
    }
    
    
    /**
     * DBClass::prepareQuery()
     * 
     * This function prepares a SQL query to be executed by the class
     * 
     * @access  public
     * @param   string $query - The SQL query to be prepared
     * @return  bool - If the query was successfully prepared or not
     */
    public function prepareQuery($query)
    {
        try
        {
            // unset the PDOStatement instance of the class
            if ($this->stmnt)
                $this->stmnt = null;
                
            // Attempt to prepare the query
            $this->stmnt = $this->conn->prepare($query);
            // Set the last query
            $this->lastQuery = $query;
            
            if ($this->stmnt)
                return true;
        }
        catch(PDOException $ex)
        {
            $this->lastQuery = $query;
            //return $this->handleQueryException("Unable to prepare the query");
            $errInfo = $this->conn->errorInfo();
            throw new QueryException($errInfo[2], $this->conn->errorCode(), $query, 'Query could not be prepared');
        }
    }
    
    
    /**
     * DBClass::bindParamToVar()
     * 
     * This function binds a parameter to a php variable
     * The function throws a QueryException if the binding failed and an Exception if the statement obj does not exist
     * It returns TRUE if the bind was success
     * 
     * @param   mixed $params - The label of the parameter to be bound to the variable
     * @param   mixed $var - The variable to be bound to the parameter
     * @param   int $dataType - The Data type of the parameter to be bound to the variable
     *                          This can be any of DBClass::TYPE_STR, DBClass::TYPE_INT, DBClass::TYPE_BOOL, DBClass::TYPE_INOUT (should be used with a | and any other type)
     * @param   int $len - The length of the dataType
     * @throws  QueryException, Exception
     * @return  bool
     */
    public function bindParamToVar($param, &$var, $dataType=self::TYPE_STR, $len=0)
    {
        // Check the Statement object
        $this->checkstmntObj();
        
        $resp = null;
            
        // Now bind the parameter
        $length = intval($len);
        if ($length > 0)
            $resp = $this->stmnt->bindParam($param, $var, $dataType, $length);
        else   
            $resp = $this->stmnt->bindParam($param, $var, $dataType);
            
        if (!$resp)
        {
            $errInfo = $this->stmnt->errorInfo();
            throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', 'Variable binding failed');
        }
        
        return true;
        
    }
    
    /**
     * DBClass::bindParamToVal()
     * 
     * This function binds a value to the parameter in a prepared query
     * 
     * @param   mixed $param - The parameter in the prepared query
     * @param   mixed $val - The value to be bound to the parameter
     * @param   mixed $dataType - The datatype of the value. default is DBClass::TYPE_STR (string)
     * @throws  QueryException, Exception
     * @return  bool - If the value was successfully bound to the param
     */
    public function bindParamToVal($param, $val, $dataType=self::TYPE_STR)
    {
        
        // Check the Statement object
        $this->checkstmntObj();
            
        // validate the type
        $paramType = $this->checkDataType($dataType);
        
        if (!$this->stmnt->bindValue($param, $val, $paramType))
        {
            $errInfo = $this->stmnt->errorInfo();
            throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', 'Value binding failed');
        }
               
        return true;
        
    }
    
    /**
     * DBClass::bindColToVar()
     * 
     * This function binds the values to be retrieved from a column through fetch to a variable
     * 
     * @access  public
     * @param   mixed $col
     * @param   mixed $var
     * @param   mixed $dateType
     * @param   integer $maxLen
     * @throws  QueryException, Exception
     * @return  void
     */
    public function bindColToVar($col, &$var, $dateType=self::TYPE_STR, $maxLen=0)
    {
        // Check the Statement object
        $this->checkstmntObj();
                        
        // validate the type
        $paramType = $this->checkDataType($dataType);
        
        $resp = null;

        // Now bind the parameter
        $length = intval($maxLen);
        if ($length > 0)
            $resp = $this->stmnt->bindColumn($param, $var, $dataType, $length);
        else   
            $resp = $this->stmnt->bindColumn($param, $var, $dataType);
        
        if (!$resp)
        {
            $errInfo = $this->stmnt->errorInfo();
            throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', 'Column to Variable binding failed');
        }
        
    }
    
    
    /**
     * DBClass::execPrepQuery()
     * 
     * This function executes a prepared SQL statement.
     * It returns true if the statement is successfully executed otherwise false
     * 
     * @access  public
     * @param   array $params
     * @throws  QueryException, Exception
     * @return  bool - If the prepared query was successfully executed or not
     */
    public function execPrepQuery(array $params=array())
    {
        try
        {
            if (!is_array($params))
                throw new Exception("Parameters passed in MUST be an array");
               
            $this->checkstmntObj();
            
            $resp = null;
            // Check if params where passed in
            if (!empty($params))
                $resp = $this->stmnt->execute($params);
            else
                $resp = $this->stmnt->execute();
                
            if (!$resp)
            {
                $errInfo = $this->stmnt->errorInfo();
                throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', 'Prepared Query could not be executed');
            }
            
            return true;

        }        
        catch (PDOException $pex)
        {            
            $errInfo = $this->conn->errorInfo(); //echo $pex->getCode();
            throw new QueryException($pex->getMessage(), $errInfo[1], '', 'An error occured while performing the requested task');
        }
    }
   

    /**
     * DBClass::fetchValues()
     * 
     * This method fetches the data from a prepared query
     * 
     * @access  public
     * @param   mixed $fetchMode
     * @param   bool $fetchAll - If all the values should be fetched
     * @throws  QueryException, Exception
     * @return  array
     */
    public function fetchValues($fetchMode, $fetchAll=false)
    {
        // Check if a statement object exists
        $this->checkstmntObj();
            
        // validate the fetch mode
        $validMode = $this->checkFetchMode($fetchMode);
        //
        try
        {
            // fetch the data
            if ($fetchAll)
                $resp = $this->stmnt->fetchAll($validMode);
            else
                $resp = $this->stmnt->fetch($validMode);
            //$resp = $this->stmnt->fetchAll();
            // throw an exception if something went wrong
            if ($resp === false)
            {
                $errInfo = $this->stmnt->errorInfo();
                throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', 'Requested data could not be fetched');
            }
                
            // return the data
            return $resp;
        }
        catch (PDOException $pex)
        {
            $errInfo = $this->conn->errorInfo();
            throw new QueryException($errInfo[2], $this->conn->errorCode(), '', 'An error occured while performing the requested task');
        }
    }
    
    /**
     * DBClass::escapeParam()
     * 
     * This function escapes the params passed to avoid SQL injection
     * The function can treat an array of values and also a single value
     * 
     * @access  public
     * @param   mixed $params - The params to be escaped or quoted. Can be an array or a variable
     * @throws  Exception
     * @return  mixed $cleanParams | $clean - The escaped values  
     */
    public function escapeParam($params)
    {
        // validate that a connection exists before proceeding
        $this->checkConnObj();
            
        // Decide if its an array
        if (is_array($params))
        {
            $cleanParams = array();
            
            foreach($params as $key => $val)
            {
                // use PDO::quote() to escape the value
                $cleanParams[$key] = $this->conn->quote($val);
            }
            // return the clean array
            return $cleanParams;
        }
        else
        {
            // escape the param
            $clean = $this->conn->quote($params);
            return $clean;
        }
    }
    
    /**
     * DBClass::setFetchMode()
     * 
     * This function sets the default fetch mode when fetchValue will be called
     * When mode is set to DBClass::TYPE_CLASS, the second param must be a string with the name of the class to store the data
     *  and the 3rd param can be left empty or set as an array of the params for the constructor of the class
     * When mode is set to DBClass::TYPE_INTO, the second param must be an instantiated object of a class that will store the data
     * 
     * @access  public
     * @param   mixed $mode - The fetch mode
     * @param   mixed $classObj - The class name or class object for TYPE_CLASS or TYPE_INTO respectively
     * @param   mixed $params - The params for the constructor of the specified class if TYPE_CLASS is passed as param 2 
     * @return  bool - If the operation was successful or not
     */
    public function setFetchMode($mode, $classObj=null, $params=null)
    {
        // Check if a statement object exists
        $this->checkstmntObj();
            
        // Check the mode
        $modeType = $this->checkFetchMode($mode);
        
        $resp = null;
        $errmsg = "Fetch Mode could not be set";
        
        try
        {
            // decide the specific fetch mode function to be called
            if ($modeType == PDO::FETCH_CLASS)
            {
                // Ensure that $classObj is a string for the class name
                if (!is_string($classObj))
                    throw new Exception("Class name was not specified");
                // Ensure that $params is an array if its passed in
                if ($params != null && !is_array($params))
                    throw new Exception("Class Constructor parameters must be passed as an array");
                // Call the fetch method
                $resp = $this->stmnt->setFetchMode($modeType, $classObj, $params);
                
                if ($resp === false)
                {
                    $errInfo = $this->stmnt->errorInfo();
                    throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', $errmsg);
                }
            }
            elseif ($modeType == PDO::FETCH_INTO)
            {
                // Ensure that $classObj is an object of a class
                if (!is_object($classObj))
                    throw new Exception("A valid class object must be supplied");
                // Call the fetch method
                $resp = $this->stmnt->setFetchMode($modeType, $classObj);
                
                if ($resp === false)
                {
                    $errInfo = $this->stmnt->errorInfo();
                    throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', $errmsg);
                }
            }
            else
            {
                // Call the fetch method
                $resp = $this->stmnt->setFetchMode($modeType);
                
                if ($resp === false)
                {
                    $errInfo = $this->stmnt->errorInfo();
                    throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', $errmsg);
                }
            }
            
            return true;
        }
        catch (PDOException $pex)
        {
            $errInfo = $this->stmnt->errorInfo();
            throw new QueryException($errInfo[2], $this->stmnt->errorCode(), '', 'An error occured while performing the requested task');
        }
        
    }
    
    /**
     * DBClass::countCols()
     * 
     * This function retrieves the number of columns that would be returned by an SQL statement
     * 
     * @access  public
     * @param   string $query - The SQL query to be executed by this function
     * @return  int - The number of columns found or FALSE if an SQL error occured
     * */
    public function countCols($query)
    {
        // validate that the query is a valid SELECT query
        if (substr(strtolower(ltrim($query)), 0, 6) != 'select')
        {
            $errmsg = 'only SELECT queries are allowed in this function';
            throw new QueryException($errmsg, 4000, $query, $errmsg);
        }
        try
        {
            // Execute the query
            $stmnt = $this->conn->query($query);
            ###
            ## SQL Error Checking goes here
            ###
            if (!$stmnt)
            {
                $errInfo = $this->conn->errorInfo();
                throw new QueryException($errInfo[2], $errInfo[1], $query, 'The requested count operation failed');
            }
            
            //return the number of columns found
            return $stmnt->columnCount();
        }
        catch (PDOException $pex)
        {
            $this->lastQuery = $query;
            //return $this->handleQueryException();
            throw new QueryException($pex->getMessage(), $pex->getCode(), $query, 'The requested operation failed');
        }   
        
    }
    
    /**
     * DBClass::lastInsertId()
     * 
     * This function returns the last insert ID for an insert operation
     * 
     * @access  public
     * @throws  QueryException, ConnException, Exception
     * @return  int
     * @todo    verify that this method returns the correct value
     */
    public function lastInsertId()
    {
        //TODO : Test this method to ensure it returns the correct value. Revert if it doesnt
        /*
        $query = "SELECT LAST_INSERT_ID() AS last_id";
        
        $record = $this->execQuery($query);
        
        return $record[0]['last_id']; 
        */
        return $this->conn->lastInsertId();
    }
    
    /**
     * DBClass::beginTransaction()
     * 
     * This function marks the start of a transaction operation. 
     * All subsequent SQL operations will not be committed until DBClass::commit() is called
     * 
     * @access  public
     * @throws  ConnException
     * @return  bool
     */
    public function beginTransaction()
    {
        // Check the connection object
        if ($this->checkConnObj())
        {
            return $this->conn->beginTransaction();
        }
    }
    
    /**
     * DBClass::commit()
     * 
     * This method commits DB operations that have been performed since DBClass::beginTransaction() was called
     * 
     * @access  public
     * @throws  ConnException
     * @return  bool
     */
    public function commit()
    {
        // Check the connection object before proceding
        if ($this->checkConnObj())
        {
            return $this->conn->commit();
        }
    }
    
    /**
     * DBClass::rollback()
     * 
     * This method rolls back all SQL operations that have been performed since the last call to DBClass::beginTransaction()
     * The method returns the status of the operation if successful or not
     * 
     * @access  public
     * @throws  ConnException
     * @return  bool
     */
    public function rollback()
    {
        // Check the connection object before proceding
        if ($this->checkConnObj())
        {
            return $this->conn->rollBack();
        }
    }
    
    /**
     * DBClass::checkstmntObj()
     * 
     * This function determines if the $stmnt member of the class is a valid PDOStatement instance
     * A valid query must be prepared using self::prepareQuery() before this method can be called
     * 
     * @return bool
     */
    protected function checkstmntObj()
    {
        if ($this->checkConnObj())
        {
            if (!(is_a($this->stmnt, 'PDOStatement')))
                throw new Exception ('No prepared statement object available');
            
            return true; 
        }
                            
    }
       
    /**
     * DBClass::checkConnObj()
     * 
     * This function checks if a valid connection exists and if its an instance of PDO class
     * 
     * @return bool
     */
    protected function checkConnObj()
    {
        if (!(is_a($this->conn, 'PDO')))
            //throw new Exception("Connection not available");
            throw new ConnException('DB Connection not available', 1000, 'DB Connection has not being set');
        
        return true; 
    }
    
    /**
     * DBClass::checkDataType()
     * 
     * @access  protected
     * @param   mixed $type
     * @return  void
     */
    protected function checkDataType($type)
    {
        //
        $validType = '';
        switch($type)
        {
            case self::TYPE_INT : $validType = PDO::PARAM_INT;
                break;
                
            case self::TYPE_BOOL : $validType = PDO::PARAM_BOOL;
                break;
                
            case self::TYPE_IN_OUT : $validType = PDO::PARAM_INPUT_OUTPUT;
                break;
                                
            case self::TYPE_STR:
            default: $validType = PDO::PARAM_STR;
        }
        
        return $validType;
    }
    
    /**
     * DBClass::checkFetchMode()
     * 
     * @param mixed $mode
     * @return
     */
    protected function checkFetchMode($mode)
    {
        //
        $validMode = '';
        switch($mode)
        {
            case self::FETCH_MODE_OBJ : $validMode = PDO::FETCH_OBJ;
                break;
            case self::FETCH_MODE_INTO : $validMode = PDO::FETCH_INTO;
                break;
            case self::FETCH_MODE_NUM : $validMode = PDO::FETCH_NUM;
                break;
            case self::FETCH_MODE_CLASS : $validMode = PDO::FETCH_CLASS;
                break;
            case self::FETCH_MODE_BOTH : $validMode = PDO::FETCH_BOTH;
                break;
            case self::FETCH_MODE_BIND : $validMode = PDO::FETCH_BOUND;
                break;
                
            case self::FETCH_MODE_ASSOC:
            default:
                $validMode = PDO::FETCH_ASSOC;
                break;
        }
        
        return $validMode;
    }


    
}

?>